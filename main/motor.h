
#ifndef __MOTOR_H__
#define __MOTOR_H__


#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/portmacro.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "driver/periph_ctrl.h"
#include "driver/mcpwm.h"
#include "driver/gpio.h"
#include "driver/pcnt.h"
#include "esp_attr.h"
#include "esp_log.h"
#include "soc/gpio_sig_map.h"
#include "soc/mcpwm_reg.h"
#include "soc/mcpwm_struct.h"


/**
 * TEST CODE BRIEF
 *
 * Use PCNT module to count rising edges generated by LEDC module.
 *
 * Functionality of GPIOs used in this example:
 *   - GPIO4 - pulse input pin,
 *   - GPIO5 - control input pin.
 *
 * Load example, open a serial port to view the message printed on your screen.
 *
 * To do this test, you should connect GPIO18 with GPIO4.
 * GPIO5 is the control signal, you can leave it floating with internal pull up,
 * or connect it to ground. If left floating, the count value will be increasing.
 * If you connect GPIO5 to GND, the count value will be decreasing.
 *
 * An interrupt will be triggered when the counter value:
 *   - reaches 'thresh1' or 'thresh0' value,
 *   - reaches 'l_lim' value or 'h_lim' value,
 *   - will be reset to zero.
 */
#define PCNT_TEST_UNIT      PCNT_UNIT_0
#define PCNT_H_LIM_VAL      ((int16_t) 0x7FFF)
#define PCNT_L_LIM_VAL      ((int16_t) 0x8000)




class Motor{
public:
   Motor();
   void initEncoder( pcnt_unit_t pcntUnit, int pinA, int pinB);
   void initPWM( mcpwm_unit_t mcpwmUnit, uint32_t freq, int pinA, int pinB);
   void setSpeed( float speed);	// from -100 to +100
   int32_t position();
private:
   pcnt_unit_t encoderNum;	// Which encoder this is using
   mcpwm_unit_t mcpwmNum;	// Which motor controller this is using
   
};


typedef struct MotorConfig {
   int encoder0A;
   int encoder0B;

   int encoder1A;
   int encoder1B;

   int motor0A;
   int motor0B;
   
   int motor1A;
   int motor1B;

} motor_config_t;


static motor_config_t motorPinOut = {
		      .encoder0A = 33,
		      .encoder0B = 32,
		      
		      .encoder1A = 26,
		      .encoder1B = 25,

		      .motor0A = 13,
		      .motor0B = 12,
		      
		      .motor1A = 27,
		      .motor1B = 14,

};

typedef struct ControlConfig {
   float p;
   float i;
   float d;

   int32_t previousError;
   int32_t integral;
   
} control_config_t;

void initMotors( motor_config_t config);

/* Task that controls motors */
void motorControl(void *arg);

/* ############################################################ */
/* #############  BRAINSTORMING STRUCTURE BELOW  ############## */
/* ############################################################ */

/* 
A queue that holds the equations that indicate the set point over time
(so each item will be an equation that generates encoder set points)

There should also be a function to change the state of the system
(like an emergency stop)
States:
running - going through queue
off     - motors off, no position hold
pause   - stay in current position

 */

/* /\* Do I want seperate control for each motor? (probably not) *\/ */
/* struct motorControlConfig { */
/*    float Kp; */
/*    float Ki; */
/*    float Kd; */
/*    int period;			/\* in mSec *\/ */
/*    int status;			/\* off, pause/hold, running *\/ */
/* }; */


/* /\* Do I need this? *\/ */
/* void getMotorPosition( int32_t * pos0, int32_t * pos1); */


/* int initiateMotors( struct motorConfig); */
/* int startMotorControl(struct motorControlConfig); */
/* int updateMotorControl(struct motorControlConfig); */

/* void setMotorPosition( int32_t pos0, int32_t pos1); */



/* First steps:
create config function that takes config struct and initializes everything

Then create control task that is fed by a queue


 */

#endif /* __MOTOR_H__ */
